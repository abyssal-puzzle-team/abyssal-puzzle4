<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深渊迷宫 - Meta谜题</title>
    <style>
        /* CSS 样式保持不变，它们与功能问题无关 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* 时间血条 */
        .time-bar-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            z-index: 1000;
        }

        .time-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #333, #555);
            border: 2px solid #00ffff;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            transform: skew(-10deg);
        }

        .time-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600, #ffff00, #00ff00);
            transition: width 1s ease-in-out;
            width: 100%;
        }

        .time-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) skew(10deg);
            font-weight: bold;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 14px;
        }

        /* 主容器 */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding-top: 70px;
        }

        /* 迷宫区域 */
        .maze-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            min-height: 60vh;
        }

        .maze-grid {
            display: grid;
            grid-template-columns: repeat(16, 40px);
            grid-template-rows: repeat(6, 40px);
            gap: 2px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #00ffff;
        }

        .maze-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .maze-cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        /* 不同类型的格子样式 */
        .cell-wall { background: #444; color: #666; cursor: not-allowed; }
        .cell-empty { background: #222; color: #aaa; }
        .cell-start { background: #00ff00; color: #000; font-weight: bold; }
        .cell-key { background: #ffff00; color: #000; }
        .cell-door { background: #8b4513; color: #fff; }
        .cell-trap { background: #ff0000; color: #fff; }
        .cell-power { background: #0080ff; color: #fff; }
        .cell-card { background: #ff00ff; color: #fff; }
        .cell-elevator { background: #00ffff; color: #000; }
        .cell-player { background: #00ff00; border: 3px solid #fff; animation: pulse 1s infinite; }
        .cell-visible { opacity: 1; }
        .cell-hidden { opacity: 0.3; background: #111; } /* 确保隐藏的格子也有背景和半透明 */
        .cell-unlocked { background: #666; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* 信息面板 */
        .info-panel {
            height: 300px;
            display: flex;
            background: rgba(0, 0, 0, 0.8);
            border-top: 2px solid #00ffff;
        }

        .status-panel, .clues-panel {
            flex: 1;
            padding: 20px;
            border-right: 1px solid #333;
        }

        .clues-panel {
            border-right: none;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #00ffff;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .status-item {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-label {
            color: #ccc;
        }

        .status-value {
            color: #00ff00;
            font-weight: bold;
        }

        .clue-item {
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid #00ffff;
            border-radius: 3px;
            font-size: 14px;
        }

        /* 模态框样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            margin: 10% auto;
            padding: 30px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            color: #fff;
            position: relative;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 10px;
        }

        .close:hover {
            color: #fff;
        }

        /* 谜题输入框 */
        .puzzle-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
        }

        .puzzle-input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        /* 按钮样式 */
        .btn {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* 4x4谜题输入区域 */
        .puzzle-4x4 {
            display: none;
            margin-top: 20px;
        }

        .puzzle-4x4-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .puzzle-4x4-input {
            padding: 10px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
        }

        /* 逃生按钮 */
        .escape-btn {
            background: linear-gradient(45deg, #ff0000, #ff6600);
            color: #fff;
            font-size: 18px;
            padding: 15px 30px;
            margin-top: 20px;
        }

        /* 冷却提示 */
        .cooldown-notice {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
            color: #ff6666;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .maze-grid {
                grid-template-columns: repeat(16, 25px);
                grid-template-rows: repeat(6, 25px);
            }
            
            .maze-cell {
                width: 25px;
                height: 25px;
                font-size: 10px;
            }
            
            .info-panel {
                flex-direction: column;
                height: auto;
            }
            
            .time-bar-container {
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <!-- 时间血条 -->
    <div class="time-bar-container">
        <div class="time-bar">
            <div class="time-bar-fill" id="timeBarFill"></div>
            <div class="time-text" id="timeText">剩余时间: --:--</div>
        </div>
    </div>

    <!-- 主容器 -->
    <div class="main-container">
        <!-- 迷宫区域 -->
        <div class="maze-container">
            <div class="maze-grid" id="mazeGrid">
                <!-- 迷宫格子将通过JavaScript动态生成 -->
            </div>
        </div>

        <!-- 信息面板 -->
        <div class="info-panel">
            <!-- 状态面板 -->
            <div class="status-panel" id="statusPanel">
                <div class="panel-title">状态信息</div>
                <div class="status-item">
                    <span class="status-label">当前位置:</span>
                    <span class="status-value" id="playerPosition">[0,0]</span>
                </div>
                <div class="status-item">
                    <span class="status-label">钥匙数量:</span>
                    <span class="status-value" id="keyCount">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">电力装置:</span>
                    <span class="status-value" id="powerCount">0/3</span>
                </div>
                <div class="status-item">
                    <span class="status-label">门禁卡:</span>
                    <span class="status-value" id="cardStatus">未获得</span>
                </div>
                <div class="status-item">
                    <span class="status-label">剩余时间:</span>
                    <span class="status-value" id="timeRemaining">--:--</span>
                </div>
            </div>

            <!-- 线索面板 -->
            <div class="clues-panel" id="cluesPanel">
                <div class="panel-title">已获得线索</div>
                <div id="cluesList">
                    <div style="color: #666; font-style: italic;">暂无线索</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 小谜题模态框 -->
    <div id="puzzleModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closePuzzleModal()">×</span>
            <h2>解决谜题以继续前进</h2>
            <div id="puzzleContent">
                <p id="puzzleQuestion">正在加载谜题...</p>
                <input type="text" id="puzzleAnswer" class="puzzle-input" placeholder="请输入答案">
                <div id="cooldownNotice" class="cooldown-notice" style="display: none;">
                    <p>答案错误！请等待 <span id="cooldownTime">0</span> 秒后重试</p>
                </div>
                <button class="btn" onclick="submitPuzzleAnswer()">提交答案</button>
                <button class="btn" onclick="skipPuzzle()" style="background: linear-gradient(45deg, #ff6600, #ff0000); color: #fff;">跳过谜题 (扣除时间)</button>
            </div>
        </div>
    </div>

    <!-- 守门员谜题模态框 -->
    <div id="goalkeeperModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeGoalkeeperModal()">×</span>
            <h2 id="goalkeeperTitle">守门员谜题</h2>
            <div id="goalkeeperContent">
                <p id="goalkeeperDescription">请输入正确的密钥以通过守门员：</p>
                <input type="text" id="goalkeeperAnswer" class="puzzle-input" placeholder="请输入密钥">
                <div id="goalkeeperCooldown" class="cooldown-notice" style="display: none;">
                    <p>密钥错误！请等待 <span id="goalkeeperCooldownTime">0</span> 秒后重试</p>
                </div>
                <button class="btn" onclick="submitGoalkeeperAnswer()">提交密钥</button>
            </div>
        </div>
    </div>

    <!-- 4x4谜题模态框 -->
    <div id="puzzle4x4Modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="close4x4Modal()">×</span>
            <h2>逃生谜题 - 4x4逻辑推理</h2>
            <div id="puzzle4x4Content">
                <p>请根据线索填入正确的数字排列：</p>
                <p style="color: #ffff00; margin: 10px 0;">格式：每行输入4个数字，用空格分隔</p>
                
                <div class="puzzle-4x4-grid">
                    <input type="text" class="puzzle-4x4-input" id="row1" placeholder="1 2 3 4">
                    <input type="text" class="puzzle-4x4-input" id="row2" placeholder="4 3 2 1">
                    <input type="text" class="puzzle-4x4-input" id="row3" placeholder="2 5 1 4">
                    <input type="text" class="puzzle-4x4-input" id="row4" placeholder="1 2 3 4">
                </div>
                
                <div id="puzzle4x4Cooldown" class="cooldown-notice" style="display: none;">
                    <p>答案错误！请等待 <span id="puzzle4x4CooldownTime">0</span> 秒后重试</p>
                </div>
                
                <button class="btn" onclick="submit4x4Answer()">提交答案</button>
                <button class="btn escape-btn" onclick="attemptEscape()" id="escapeBtn">逃生</button>
            </div>
        </div>
    </div>

    <script>
        // 游戏状态
        let gameState = {
            playerX: 0,
            playerY: 0,
            keys: 0,
            powerDevices: 0,
            hasCard: false,
            // 唯一的状态源，记录所有已访问/解锁的格子坐标 ('x,y')
            unlockedCells: new Set(['0,0']), 
            clues: [],
            username: '',
            password: '',
            metaTimeRemaining: 0,
            puzzle4x4Solved: false,
            elevatorCluesObtained: false
            // 移除了 activatedPowerDevices
        };

        // 迷宫地图定义
        const mazeMap = [
            // ... (地图数据不变) ...
            ['start', 'empty', 'wall', 'wall', 'empty', 'empty', 'empty', 'empty', 'wall', 'card', 'wall', 'wall', 'key', 'wall', 'wall', 'power'],
            ['empty', 'empty', 'empty', 'empty', 'empty', 'wall', 'key', 'empty', 'empty', 'empty', 'wall', 'empty', 'empty', 'door', 'empty', 'trap'],
            ['empty', 'wall', 'empty', 'wall', 'empty', 'wall', 'wall', 'empty', 'wall', 'empty', 'door', 'empty', 'empty', 'wall', 'elevator', 'empty'],
            ['empty', 'empty', 'empty', 'wall', 'empty', 'empty', 'wall', 'empty', 'wall', 'empty', 'wall', 'empty', 'empty', 'empty', 'wall', 'empty'],
            ['wall', 'wall', 'empty', 'wall', 'empty', 'door', 'empty', 'empty', 'door', 'empty', 'wall', 'empty', 'wall', 'trap', 'empty', 'empty'],
            ['wall', 'power', 'trap', 'wall', 'key', 'wall', 'empty', 'wall', 'door', 'empty', 'empty', 'empty', 'door', 'empty', 'power', 'wall']
        ];
        
        // 坐标 -> ID/信息 映射
        const powerDeviceLocations = {
            '1,5': { clues: [0, 1] },   // [x,y]: { clues: [clue_index_1, clue_index_2] }
            '14,5': { clues: [2, 3] },
            '15,0': { clues: [4, 5] }
        };
        const trapLocations = { 'A1': [2, 5], 'B2': [13, 4], 'C3': [15, 1] };

        const allClues = [
            "1和16在对角端点", "2在3左侧且不相邻", "4,5,6是第4行从左至右连续的三个数字",
            "7在第1列，8在第1行，7与8不在角落", "9不在角落且正下方相邻是11", "10在11正上方",
            "12在13相邻正上方", "14与16同列，15在14相邻正下方"
        ];

        const API_BASE = 'http://111.170.11.168:15114/proxy/3000';

        // 初始化游戏
        async function initGame() {
            initMaze();
            await loadUserData();
            initMaze(); // 使用加载的数据重新绘制
            const shouldContinueGame = await checkProgress();
            if (!shouldContinueGame) return;
            startTimeMonitoring();
            updateDisplay();
        }

        // 加载用户数据
        async function loadUserData() {
            try {
                gameState.username = getCookie('username');
                gameState.password = getCookie('password');
                if (!gameState.username || !gameState.password) {
                    alert('请先登录或注册账号以保存游戏进度！');
                    return;
                }
                const response = await fetch(`${API_BASE}/acc_check_password`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: 'include', body: JSON.stringify({ username: gameState.username, password: gameState.password }) });
                const data = await response.json();

                if (data.success && data.user_data) {
                    const userData = data.user_data;
                    
                    // 恢复基本状态
                    if (userData.meta_xy) try { const coords = JSON.parse(userData.meta_xy); gameState.playerX = coords[0]; gameState.playerY = coords[1]; } catch(e) {}
                    gameState.keys = parseInt(userData.meta_key_number) || 0;
                    gameState.hasCard = userData.meta_card === true || userData.meta_card === 'true';

                    // 从 meta_progress 恢复所有已解锁的格子
                    gameState.unlockedCells.clear();
                    gameState.unlockedCells.add('0,0');
                    if (userData.meta_progress) {
                        const matches = userData.meta_progress.match(/\[\d+,\d+\]/g);
                        if (matches) {
                            matches.forEach(matchStr => {
                                try {
                                    const coords = JSON.parse(matchStr);
                                    gameState.unlockedCells.add(`${coords[0]},${coords[1]}`);
                                } catch (e) {}
                            });
                        }
                    }
                    
                    // 核心改动：根据恢复的 unlockedCells 推断电力装置和线索状态
                    gameState.powerDevices = 0;
                    gameState.clues = [];
                    
                    gameState.unlockedCells.forEach(cellKey => {
                        if (powerDeviceLocations[cellKey]) {
                            gameState.powerDevices++;
                            const deviceClues = powerDeviceLocations[cellKey].clues;
                            deviceClues.forEach(clueIndex => {
                                const clue = allClues[clueIndex];
                                if (!gameState.clues.includes(clue)) {
                                    gameState.clues.push(clue);
                                }
                            });
                        }
                    });

                    // 恢复电梯线索
                    gameState.elevatorCluesObtained = userData.meta_elevator_clues_obtained === true || userData.meta_elevator_clues_obtained === 'true';
                    if (gameState.elevatorCluesObtained) {
                        if (!gameState.clues.includes(allClues[6])) gameState.clues.push(allClues[6]);
                        if (!gameState.clues.includes(allClues[7])) gameState.clues.push(allClues[7]);
                    }

                    // 恢复4x4谜题状态
                    gameState.puzzle4x4Solved = userData.meta_4x4_solved === true || userData.meta_4x4_solved === 'true';
                    
                    // 不再需要从 meta_power_number 或 meta_activated_power_devices 恢复
                    console.log('用户数据加载完成:', gameState);

                } else {
                    alert('登录失败：' + data.message);
                }
            } catch (error) {
                console.error('加载用户数据失败:', error);
            }
        }
        
        // 设置格子外观
        function setCellAppearance(cell, cellType, x, y, isVisible, isUnlocked) {
            cell.className = 'maze-cell';
            const cellKey = `${x},${y}`;

            if (!isVisible) {
                cell.classList.add('cell-hidden');
                cell.textContent = '?';
                return;
            }

            if (x === gameState.playerX && y === gameState.playerY) {
                cell.classList.add('cell-player');
                cell.textContent = '玩家';
                return;
            }
            
            // 统一逻辑：只要在 unlockedCells 中，就显示为已解锁
            if (gameState.unlockedCells.has(cellKey)) {
                cell.classList.add('cell-empty');
                cell.textContent = '✓';
                return;
            }
            
            // 未解锁时，按类型显示
            switch (cellType) {
                case 'wall': cell.classList.add('cell-wall'); cell.textContent = '墙'; break;
                case 'empty': cell.classList.add('cell-empty'); cell.textContent = '空'; break;
                case 'start': cell.classList.add('cell-start'); cell.textContent = '起点'; break;
                case 'key': cell.classList.add('cell-key'); cell.textContent = '钥匙'; break;
                case 'door': cell.classList.add('cell-door'); cell.textContent = '门'; break;
                case 'trap': cell.classList.add('cell-trap'); cell.textContent = '陷阱'; break;
                case 'power': cell.classList.add('cell-power'); cell.textContent = '电力'; break;
                case 'card': cell.classList.add('cell-card'); cell.textContent = '卡片'; break;
                case 'elevator': cell.classList.add('cell-elevator'); cell.textContent = '电梯'; break;
            }
        }
        
        // 移动到指定格子 - 最终简化版
        async function moveToCell(x, y) {
            if (!canMoveTo(x, y)) return;

            const cellKey = `${x},${y}`;
            
            // 统一检查：如果已解锁，直接移动
            if (gameState.unlockedCells.has(cellKey)) {
                movePlayer(x, y);
                return;
            }
            
            // 如果未解锁，处理首次交互
            const cellType = mazeMap[y][x];
            switch (cellType) {
                case 'empty':  await handleEmptyCell(x, y); break;
                case 'door':   await handleDoorCell(x, y); break;
                case 'key':    await handleKeyCell(x, y); break;
                case 'trap':   handleTrapCell(x, y); break;
                case 'power':  await handlePowerCell(x, y); break; // 只在首次点击时调用
                case 'card':   await handleCardCell(x, y); break;
                case 'elevator': await handleElevatorCell(x, y); break;
                case 'start':  movePlayer(x, y); break;
                default:       movePlayer(x, y); break;
            }
        }
        
        // 处理电力装置格子 (仅在首次激活时被调用)
        async function handlePowerCell(x, y) {
            const cellKey = `${x},${y}`;
            
            // 1. 更新游戏状态
            gameState.powerDevices++;
            
            // 2. 解锁格子 (这会自动更新unlockedCells并保存到后端)
            await unlockCell(x, y); 

            // 3. 获取并显示线索
            const deviceConfig = powerDeviceLocations[cellKey];
            if (deviceConfig) {
                let newlyAddedClues = [];
                deviceConfig.clues.forEach(clueIndex => {
                    const clue = allClues[clueIndex];
                    if (!gameState.clues.includes(clue)) {
                        gameState.clues.push(clue);
                        newlyAddedClues.push(clue);
                    }
                });
                if (newlyAddedClues.length > 0) {
                    alert(`激活电力装置成功！获得了新线索：\n- ${newlyAddedClues.join('\n- ')}`);
                } else {
                    alert('激活电力装置成功！');
                }
            }
            
            // 4. 更新显示面板
            updateDisplay();
            
            // 5. 移动玩家
            movePlayer(x, y);
        }

        // 解锁格子 (统一的核心函数)
        async function unlockCell(x, y) {
            const cellKey = `${x},${y}`;
            if (!gameState.unlockedCells.has(cellKey)) {
                gameState.unlockedCells.add(cellKey);
                await addMetaProgress(x, y);
                console.log(`Cell [${x},${y}] unlocked and saved to backend.`);
            }
            // 强制重绘以应用 '✓' 样式
            initMaze();
        }
        
        // 提交小谜题答案
        async function submitPuzzleAnswer() {
            const answer = document.getElementById('puzzleAnswer').value.trim();
            const target = window.currentPuzzleTarget;
            if (!target) return;
            
            if (answer === target.answer) {
                closePuzzleModal();
                await unlockCell(target.x, target.y); // 解锁
                await diminishMetaTime();
                movePlayer(target.x, target.y); // 移动
            } else {
                await startSimpleCooldown();
                const cooldownStatus = await checkSimpleCooldown();
                showCooldownNotice('simple', cooldownStatus.cooldownRemaining);
            }
        }
        
        // 处理陷阱解谜消息
        window.addEventListener('message', async function(event) {
            if (event.data && event.data.type === 'trapSolved') {
                const { trapCoords } = event.data;
                const x = trapCoords[0];
                const y = trapCoords[1];
                
                await unlockCell(x, y); // 直接调用统一的解锁函数
                
                if (canMoveTo(x, y)) {
                    movePlayer(x, y);
                } else {
                    initMaze(); // 确保即使不移动，格子外观也更新
                }
            }
        });

        // --- 其他函数保持不变 ---
        // 为了简洁，此处省略了所有未改动的函数，它们与上一个版本完全相同
        // getCookie, initMaze, isCellVisible, canMoveTo, movePlayer, updateMazeDisplay, 
        // handleEmptyCell, handleDoorCell, handleKeyCell, handleCardCell, handleElevatorCell,
        // showPuzzleModal, closePuzzleModal, skipPuzzle, handleTrapCell,
        // show4x4Modal, close4x4Modal, submit4x4Answer, checkProgress, attemptEscape, 
        // showCooldownNotice, show4x4CooldownNotice, updateDisplay, startTimeMonitoring, 
        // updateTimeDisplay, 和所有 API 调用函数。
        // 请确保将它们从您上一个版本的代码中复制过来。

        // 页面加载完成后初始化游戏
        document.addEventListener('DOMContentLoaded', initGame);

        // --- 为了代码的完整性，将所有未修改的函数粘贴在此处 ---
        
        function getCookie(name) { const value = `; ${document.cookie}`; const parts = value.split(`; ${name}=`); if (parts.length === 2) return parts.pop().split(';').shift(); return ''; }
        function initMaze() { const mazeGrid = document.getElementById('mazeGrid'); mazeGrid.innerHTML = ''; for (let y = 5; y >= 0; y--) { for (let x = 0; x < 16; x++) { const cell = document.createElement('div'); cell.dataset.x = x; cell.dataset.y = y; const cellType = mazeMap[y][x]; const isVisible = isCellVisible(x, y); const isUnlocked = gameState.unlockedCells.has(`${x},${y}`); setCellAppearance(cell, cellType, x, y, isVisible, isUnlocked); if (isVisible && cellType !== 'wall') { cell.addEventListener('click', () => moveToCell(x, y)); } mazeGrid.appendChild(cell); } } }
        function isCellVisible(x, y) { if (x === gameState.playerX && y === gameState.playerY) return true; if (gameState.unlockedCells.has(`${x},${y}`)) return true; const dx = Math.abs(x - gameState.playerX); const dy = Math.abs(y - gameState.playerY); if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) return true; if (mazeMap[y][x] === 'wall') return true; return false; }
        function canMoveTo(x, y) { if (x < 0 || x >= 16 || y < 0 || y >= 6) return false; if (mazeMap[y][x] === 'wall') return false; const dx = Math.abs(x - gameState.playerX); const dy = Math.abs(y - gameState.playerY); return (dx === 1 && dy === 0) || (dx === 0 && dy === 1); }
        async function movePlayer(x, y) { const oldX = gameState.playerX; const oldY = gameState.playerY; gameState.playerX = x; gameState.playerY = y; await updatePlayerPosition(x, y); await diminishMetaTime(); updateMazeDisplay(oldX, oldY, x, y); updateDisplay(); }
        function updateMazeDisplay(oldX, oldY, newX, newY) { for (let dy = -2; dy <= 2; dy++) { for (let dx = -2; dx <= 2; dx++) { const checkX = newX + dx, checkY = newY + dy; if (checkX >= 0 && checkX < 16 && checkY >= 0 && checkY < 6) updateSingleCell(checkX, checkY); const oldCheckX = oldX + dx, oldCheckY = oldY + dy; if (oldCheckX >= 0 && oldCheckX < 16 && oldCheckY >= 0 && oldCheckY < 6) updateSingleCell(oldCheckX, oldCheckY); } } updateSingleCell(oldX, oldY); updateSingleCell(newX, newY); }
        function updateSingleCell(x, y) { const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`); if(cell) { const cellType = mazeMap[y][x]; const isVisible = isCellVisible(x, y); const isUnlocked = gameState.unlockedCells.has(`${x},${y}`); setCellAppearance(cell, cellType, x, y, isVisible, isUnlocked); } }
        async function handleEmptyCell(x, y) { const cooldownStatus = await checkSimpleCooldown(); if (cooldownStatus.cooldownRemaining > 0) { showCooldownNotice('simple', cooldownStatus.cooldownRemaining); return; } const puzzle = await getRandomPuzzle(); if (puzzle && puzzle.success) { showPuzzleModal(puzzle.puzzle, x, y); } else { alert('无法获取谜题，请稍后再试。'); } }
        async function handleDoorCell(x, y) { if (gameState.keys > 0) { gameState.keys--; await updateUserData('meta_key_number', gameState.keys.toString()); await unlockCell(x, y); movePlayer(x, y); } else { alert('需要钥匙才能通过这扇门！'); } }
        async function handleKeyCell(x, y) { gameState.keys++; await updateUserData('meta_key_number', gameState.keys.toString()); await unlockCell(x, y); await diminishMetaTime(); movePlayer(x, y); }
        async function handleTrapCell(x, y) { let trapId = null; for (const id in trapLocations) { if (trapLocations[id][0] === x && trapLocations[id][1] === y) { trapId = id; break; } } if (!trapId) return; const cooldownStatus = await checkGoalkeeperCooldown(); if (cooldownStatus.cooldownRemaining > 0) { alert(`守门员谜题处于冷却中，请等待 ${cooldownStatus.cooldownRemaining} 秒后重试。`); return; } window.open(`${trapId}.html?x=${x}&y=${y}`, '_blank'); }
        async function handleCardCell(x, y) { gameState.hasCard = true; await updateUserData('meta_card', 'true'); await unlockCell(x, y); await diminishMetaTime(); movePlayer(x, y); }
        async function handleElevatorCell(x, y) { movePlayer(x, y); if (!gameState.elevatorCluesObtained) { let newlyAddedClues = []; [allClues[6], allClues[7]].forEach(clue => { if (!gameState.clues.includes(clue)) { gameState.clues.push(clue); newlyAddedClues.push(clue); } }); if (newlyAddedClues.length > 0) { gameState.elevatorCluesObtained = true; await updateUserData('meta_elevator_clues_obtained', 'true'); alert(`你进入了电梯！获得了新线索：\n- ${newlyAddedClues.join('\n- ')}`); updateDisplay(); } } show4x4Modal(); }
        function showPuzzleModal(puzzleData, targetX, targetY) { document.getElementById('puzzleQuestion').textContent = puzzleData.puzzle; document.getElementById('puzzleAnswer').value = ''; document.getElementById('puzzleModal').style.display = 'block'; window.currentPuzzleTarget = { x: targetX, y: targetY, answer: puzzleData.key }; }
        function closePuzzleModal() { document.getElementById('puzzleModal').style.display = 'none'; window.currentPuzzleTarget = null; }
        async function skipPuzzle() { if (!confirm('跳过谜题将扣除额外时间，确定要跳过吗？')) return; closePuzzleModal(); await diminishMetaTime(); await diminishMetaTime(); alert('已跳过谜题，扣除了额外时间。'); }
        function show4x4Modal() { let cluesHtml = ''; if (gameState.clues.length > 0) { const sortedClues = [...gameState.clues].sort((a, b) => allClues.indexOf(a) - allClues.indexOf(b)); cluesHtml = sortedClues.map(clue => `<div class="clue-item">${clue}</div>`).join(''); } else { cluesHtml = `<div style="margin: 15px 0; color: #ff6666;"><h4>提示：</h4><p>您还没有获得任何线索！请先激活电力装置和电梯来获取线索。</p></div>`; } document.getElementById('puzzle4x4Content').innerHTML = `<p>请根据所有线索填入正确的数字排列：</p><div style="margin: 15px 0;"><h4>已获得的线索：</h4>${cluesHtml}</div><p style="color: #ffff00; margin: 10px 0;">格式：每行输入4个数字，用空格分隔</p><div class="puzzle-4x4-grid"><input type="text" class="puzzle-4x4-input" id="row1" placeholder="1 2 3 4"><input type="text" class="puzzle-4x4-input" id="row2" placeholder="4 3 2 1"><input type="text" class="puzzle-4x4-input" id="row3" placeholder="2 5 1 4"><input type="text" class="puzzle-4x4-input" id="row4" placeholder="1 2 3 4"></div><div id="puzzle4x4Cooldown" class="cooldown-notice" style="display: none;"><p>答案错误！请等待 <span id="puzzle4x4CooldownTime">0</span> 秒后重试</p></div><button class="btn" onclick="submit4x4Answer()">提交答案</button><button class="btn escape-btn" onclick="attemptEscape()" id="escapeBtn">逃生</button>`; document.getElementById('puzzle4x4Modal').style.display = 'block'; }
        function close4x4Modal() { document.getElementById('puzzle4x4Modal').style.display = 'none'; }
        async function submit4x4Answer() { const cooldownStatus = await check4x4Cooldown(); if (cooldownStatus.cooldownRemaining > 0) { show4x4CooldownNotice(cooldownStatus.cooldownRemaining); return; } const keys = [document.getElementById('row1').value.trim(), document.getElementById('row2').value.trim(), document.getElementById('row3').value.trim(), document.getElementById('row4').value.trim()]; const response = await fetch(`${API_BASE}/check_4x4_key`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: 'include', body: JSON.stringify({ username: gameState.username, keys: keys }) }); const data = await response.json(); if (data.success) { gameState.puzzle4x4Solved = true; await updateUserData('meta_4x4_solved', 'true'); alert('4x4谜题解决成功！'); updateDisplay(); } else { await fetch(`${API_BASE}/start_4x4_cooldown`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: 'include', body: JSON.stringify({ username: gameState.username }) }); const newCooldownStatus = await check4x4Cooldown(); show4x4CooldownNotice(newCooldownStatus.cooldownRemaining); } }
        async function checkProgress() { try { const response = await fetch(`${API_BASE}/acc_check_password`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: 'include', body: JSON.stringify({ username: gameState.username, password: gameState.password }) }); const data = await response.json(); if (data.success && data.user_data && parseInt(data.user_data.progress) === 9) { const metaStatus = await getMetaStatus(); window.location.href = metaStatus.remainingSeconds > 0 ? 'ne.html' : 'be.html'; return false; } return true; } catch (error) { return true; } }
        async function attemptEscape() { if (gameState.powerDevices < 3) { alert('逃生失败：还有电力装置未激活！'); return; } if (!gameState.hasCard) { alert('逃生失败：需要门禁卡！'); return; } if (!gameState.puzzle4x4Solved) { alert('逃生失败：需要先解决4x4谜题！'); return; } const metaStatus = await getMetaStatus(); await updateUserData('progress', '9'); window.location.href = metaStatus.remainingSeconds > 0 ? 'ne.html' : 'be.html'; }
        function showCooldownNotice(type, seconds) { if (type !== 'simple') return; const notice = document.getElementById('cooldownNotice'), timeSpan = document.getElementById('cooldownTime'); timeSpan.textContent = seconds; notice.style.display = 'block'; const countdown = setInterval(() => { seconds--; timeSpan.textContent = seconds; if (seconds <= 0) { clearInterval(countdown); notice.style.display = 'none'; } }, 1000); }
        function show4x4CooldownNotice(seconds) { const notice = document.getElementById('puzzle4x4Cooldown'), timeSpan = document.getElementById('puzzle4x4CooldownTime'); timeSpan.textContent = seconds; notice.style.display = 'block'; const countdown = setInterval(() => { seconds--; timeSpan.textContent = seconds; if (seconds <= 0) { clearInterval(countdown); notice.style.display = 'none'; } }, 1000); }
        function updateDisplay() { document.getElementById('playerPosition').textContent = `[${gameState.playerX},${gameState.playerY}]`; document.getElementById('keyCount').textContent = gameState.keys; document.getElementById('powerCount').textContent = `${gameState.powerDevices}/3`; document.getElementById('cardStatus').textContent = gameState.hasCard ? '已获得' : '未获得'; const cluesList = document.getElementById('cluesList'); if (gameState.clues.length > 0) { const sortedClues = [...gameState.clues].sort((a, b) => allClues.indexOf(a) - allClues.indexOf(b)); cluesList.innerHTML = sortedClues.map(clue => `<div class="clue-item">${clue}</div>`).join(''); } else { cluesList.innerHTML = '<div style="color: #666; font-style: italic;">暂无线索</div>'; } }
        function startTimeMonitoring() { setInterval(async () => { const metaStatus = await getMetaStatus(); updateTimeDisplay(metaStatus.remainingSeconds); }, 1000); }
        function updateTimeDisplay(seconds) { const minutes = Math.floor(seconds / 60), secs = seconds % 60, timeStr = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`; document.getElementById('timeText').textContent = `剩余时间: ${timeStr}`; document.getElementById('timeRemaining').textContent = timeStr; document.getElementById('timeBarFill').style.width = `${Math.max(0, (seconds / 1800) * 100)}%`; }
        async function apiCall(endpoint, body) { try { const response = await fetch(`${API_BASE}${endpoint}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, credentials: 'include', body: JSON.stringify(body) }); return await response.json(); } catch (error) { console.error(`API call to ${endpoint} failed:`, error); return { success: false, message: 'Network error' }; } }
        async function getRandomPuzzle() { try { const response = await fetch(`${API_BASE}/random`); return await response.json(); } catch (e) { return { success: false }; } }
        async function checkSimpleCooldown() { return await apiCall('/simple_cooldown_status', { username: gameState.username }) || { cooldownRemaining: 0 }; }
        async function startSimpleCooldown() { await apiCall('/start_simple_cooldown', { username: gameState.username }); }
        async function checkGoalkeeperCooldown() { return await apiCall('/goalkeeper_cooldown_status', { username: gameState.username }) || { cooldownRemaining: 0 }; }
        async function updateUserData(option, value) { await apiCall('/set_user_data', { username: gameState.username, option, value }); }
        async function updatePlayerPosition(x, y) { await apiCall('/change_meta_xy', { username: gameState.username, new_xy: `[${x},${y}]` }); }
        async function addMetaProgress(x, y) { await apiCall('/add_meta', { username: gameState.username, progress: `[${x},${y}]` }); }
        async function diminishMetaTime() { await apiCall('/diminish_meta_time', {}); }
        async function getMetaStatus() { try { const response = await fetch(`${API_BASE}/meta-status`); return await response.json(); } catch (e) { return { remainingSeconds: 0 }; } }
        async function check4x4Cooldown() { return await apiCall('/4x4_cooldown_status', { username: gameState.username }) || { cooldownRemaining: 0 }; }

    </script>
</body>
</html>