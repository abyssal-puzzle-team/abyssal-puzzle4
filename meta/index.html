<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>深渊迷宫 - Meta谜题</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* 时间血条 */
        .time-bar-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            z-index: 1000;
        }

        .time-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #333, #555);
            border: 2px solid #00ffff;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            transform: skew(-10deg);
        }

        .time-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600, #ffff00, #00ff00);
            transition: width 1s ease-in-out;
            width: 100%;
        }

        .time-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) skew(10deg);
            font-weight: bold;
            color: #ffffff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 14px;
        }

        /* 主容器 */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding-top: 70px;
        }

        /* 迷宫区域 */
        .maze-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            min-height: 60vh;
        }

        .maze-grid {
            display: grid;
            grid-template-columns: repeat(16, 40px);
            grid-template-rows: repeat(6, 40px);
            gap: 2px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #00ffff;
        }

        .maze-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .maze-cell:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        /* 不同类型的格子样式 */
        .cell-wall { background: #444; color: #666; cursor: not-allowed; }
        .cell-empty { background: #222; color: #aaa; }
        .cell-start { background: #00ff00; color: #000; font-weight: bold; }
        .cell-key { background: #ffff00; color: #000; }
        .cell-door { background: #8b4513; color: #fff; }
        .cell-trap { background: #ff0000; color: #fff; }
        .cell-power { background: #0080ff; color: #fff; }
        .cell-card { background: #ff00ff; color: #fff; }
        .cell-elevator { background: #00ffff; color: #000; }
        .cell-player { background: #00ff00; border: 3px solid #fff; animation: pulse 1s infinite; }
        .cell-visible { opacity: 1; }
        .cell-hidden { opacity: 0.3; background: #111; }
        .cell-unlocked { background: #666; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* 信息面板 */
        .info-panel {
            height: 300px;
            display: flex;
            background: rgba(0, 0, 0, 0.8);
            border-top: 2px solid #00ffff;
        }

        .status-panel, .clues-panel {
            flex: 1;
            padding: 20px;
            border-right: 1px solid #333;
        }

        .clues-panel {
            border-right: none;
        }

        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #00ffff;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .status-item {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-label {
            color: #ccc;
        }

        .status-value {
            color: #00ff00;
            font-weight: bold;
        }

        .clue-item {
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(0, 255, 255, 0.1);
            border-left: 3px solid #00ffff;
            border-radius: 3px;
            font-size: 14px;
        }

        /* 模态框样式 */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            margin: 10% auto;
            padding: 30px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            width: 80%;
            max-width: 600px;
            color: #fff;
            position: relative;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 10px;
        }

        .close:hover {
            color: #fff;
        }

        /* 谜题输入框 */
        .puzzle-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
        }

        .puzzle-input:focus {
            outline: none;
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        /* 按钮样式 */
        .btn {
            background: linear-gradient(45deg, #00ffff, #0080ff);
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.3);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* 4x4谜题输入区域 */
        .puzzle-4x4 {
            display: none;
            margin-top: 20px;
        }

        .puzzle-4x4-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .puzzle-4x4-input {
            padding: 10px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
        }

        /* 逃生按钮 */
        .escape-btn {
            background: linear-gradient(45deg, #ff0000, #ff6600);
            color: #fff;
            font-size: 18px;
            padding: 15px 30px;
            margin-top: 20px;
        }

        /* 冷却提示 */
        .cooldown-notice {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            text-align: center;
            color: #ff6666;
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .maze-grid {
                grid-template-columns: repeat(16, 25px);
                grid-template-rows: repeat(6, 25px);
            }
            
            .maze-cell {
                width: 25px;
                height: 25px;
                font-size: 10px;
            }
            
            .info-panel {
                flex-direction: column;
                height: auto;
            }
            
            .time-bar-container {
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <!-- 时间血条 -->
    <div class="time-bar-container">
        <div class="time-bar">
            <div class="time-bar-fill" id="timeBarFill"></div>
            <div class="time-text" id="timeText">剩余时间: --:--</div>
        </div>
    </div>

    <!-- 主容器 -->
    <div class="main-container">
        <!-- 迷宫区域 -->
        <div class="maze-container">
            <div class="maze-grid" id="mazeGrid">
                <!-- 迷宫格子将通过JavaScript动态生成 -->
            </div>
        </div>

        <!-- 信息面板 -->
        <div class="info-panel">
            <!-- 状态面板 -->
            <div class="status-panel" id="statusPanel">
                <div class="panel-title">状态信息</div>
                <div class="status-item">
                    <span class="status-label">当前位置:</span>
                    <span class="status-value" id="playerPosition">[0,0]</span>
                </div>
                <div class="status-item">
                    <span class="status-label">钥匙数量:</span>
                    <span class="status-value" id="keyCount">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">电力装置:</span>
                    <span class="status-value" id="powerCount">0/3</span>
                </div>
                <div class="status-item">
                    <span class="status-label">门禁卡:</span>
                    <span class="status-value" id="cardStatus">未获得</span>
                </div>
                <div class="status-item">
                    <span class="status-label">剩余时间:</span>
                    <span class="status-value" id="timeRemaining">--:--</span>
                </div>
            </div>

            <!-- 线索面板 -->
            <div class="clues-panel" id="cluesPanel">
                <div class="panel-title">已获得线索</div>
                <div id="cluesList">
                    <div style="color: #666; font-style: italic;">暂无线索</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 小谜题模态框 -->
    <div id="puzzleModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closePuzzleModal()">&times;</span>
            <h2>解决谜题以继续前进</h2>
            <div id="puzzleContent">
                <p id="puzzleQuestion">正在加载谜题...</p>
                <input type="text" id="puzzleAnswer" class="puzzle-input" placeholder="请输入答案">
                <div id="cooldownNotice" class="cooldown-notice" style="display: none;">
                    <p>答案错误！请等待 <span id="cooldownTime">0</span> 秒后重试</p>
                </div>
                <button class="btn" onclick="submitPuzzleAnswer()">提交答案</button>
                <button class="btn" onclick="skipPuzzle()" style="background: linear-gradient(45deg, #ff6600, #ff0000); color: #fff;">跳过谜题 (扣除时间)</button>
            </div>
        </div>
    </div>

    <!-- 守门员谜题模态框 -->
    <div id="goalkeeperModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeGoalkeeperModal()">&times;</span>
            <h2 id="goalkeeperTitle">守门员谜题</h2>
            <div id="goalkeeperContent">
                <p id="goalkeeperDescription">请输入正确的密钥以通过守门员：</p>
                <input type="text" id="goalkeeperAnswer" class="puzzle-input" placeholder="请输入密钥">
                <div id="goalkeeperCooldown" class="cooldown-notice" style="display: none;">
                    <p>密钥错误！请等待 <span id="goalkeeperCooldownTime">0</span> 秒后重试</p>
                </div>
                <button class="btn" onclick="submitGoalkeeperAnswer()">提交密钥</button>
            </div>
        </div>
    </div>

    <!-- 4x4谜题模态框 -->
    <div id="puzzle4x4Modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="close4x4Modal()">&times;</span>
            <h2>逃生谜题 - 4x4逻辑推理</h2>
            <div id="puzzle4x4Content">
                <p>请根据线索填入正确的数字排列：</p>
                <p style="color: #ffff00; margin: 10px 0;">格式：每行输入4个数字，用空格分隔</p>
                
                <div class="puzzle-4x4-grid">
                    <input type="text" class="puzzle-4x4-input" id="row1" placeholder="1 2 3 4">
                    <input type="text" class="puzzle-4x4-input" id="row2" placeholder="4 3 2 1">
                    <input type="text" class="puzzle-4x4-input" id="row3" placeholder="2 5 1 4">
                    <input type="text" class="puzzle-4x4-input" id="row4" placeholder="1 2 3 4">
                </div>
                
                <div id="puzzle4x4Cooldown" class="cooldown-notice" style="display: none;">
                    <p>答案错误！请等待 <span id="puzzle4x4CooldownTime">0</span> 秒后重试</p>
                </div>
                
                <button class="btn" onclick="submit4x4Answer()">提交答案</button>
                <button class="btn escape-btn" onclick="attemptEscape()" id="escapeBtn">逃生</button>
            </div>
        </div>
    </div>

    <script>
        // 游戏状态
        let gameState = {
            playerX: 0,
            playerY: 0,
            keys: 0,
            powerDevices: 0,
            hasCard: false,
            unlockedCells: new Set(['0,0']), // 已解锁的格子
            activatedPowerDevices: new Set(), // 已激活的电力装置
            clues: [],
            username: '',
            password: '',
            metaTimeRemaining: 0,
            puzzle4x4Solved: false,
            solvedTraps: new Set() // 已解决的陷阱
        };

        // 迷宫地图定义 (6x16)
        const mazeMap = [
            // y=0 (底行)
            ['start', 'empty', 'wall', 'wall', 'empty', 'empty', 'empty', 'empty', 'wall', 'card', 'wall', 'wall', 'key', 'wall', 'wall', 'power'],
            // y=1
            ['empty', 'empty', 'empty', 'empty', 'empty', 'wall', 'key', 'empty', 'empty', 'empty', 'wall', 'empty', 'empty', 'door', 'empty', 'trap'],
            // y=2
            ['empty', 'wall', 'empty', 'wall', 'empty', 'wall', 'wall', 'empty', 'wall', 'empty', 'door', 'empty', 'empty', 'wall', 'elevator', 'empty'],
            // y=3
            ['empty', 'empty', 'empty', 'wall', 'empty', 'empty', 'wall', 'empty', 'wall', 'empty', 'wall', 'empty', 'empty', 'empty', 'wall', 'empty'],
            // y=4
            ['wall', 'wall', 'empty', 'wall', 'empty', 'door', 'empty', 'empty', 'door', 'empty', 'wall', 'empty', 'wall', 'trap', 'empty', 'empty'],
            // y=5 (顶行)
            ['wall', 'power', 'trap', 'wall', 'key', 'wall', 'empty', 'wall', 'door', 'empty', 'empty', 'empty', 'door', 'empty', 'power', 'wall']
        ];

        // 线索列表
        const allClues = [
            "1和16在对角端点",
            "2在3左侧且不相邻", 
            "4,5,6是第4行从左至右连续的三个数字",
            "7在第1列，8在第1行，7与8不在角落",
            "9不在角落且正下方相邻是11",
            "10在11正上方",
            "12在13相邻正上方",
            "14与16同列，15在14相邻正下方"
        ];

        // API基础URL
        const API_BASE = 'http://111.170.11.168:15114/proxy/3000';

        // 初始化游戏
        async function initGame() {
            // 检查登录状态并加载用户数据
            await loadUserData();
            
            // 检查进度
            if (!await checkProgress()) {
                return;
            }
            
            // 初始化迷宫
            initMaze();
            
            // 开始时间监控
            startTimeMonitoring();
            
            // 立即更新显示，确保线索正确显示
            updateDisplay();
            
            // 再次确保线索显示（防止异步问题）
            setTimeout(() => {
                updateDisplay();
                console.log('延迟更新显示完成，当前线索:', gameState.clues);
                console.log('线索面板内容:', document.getElementById('cluesList').innerHTML);
            }, 500);
            
            // 第三次确保线索显示（防止DOM渲染延迟）
            setTimeout(() => {
                updateDisplay();
                console.log('第三次更新显示完成，当前线索:', gameState.clues);
                console.log('线索面板内容:', document.getElementById('cluesList').innerHTML);
            }, 1000);
        }

        // 加载用户数据
        async function loadUserData() {
            try {
                // 从cookie获取用户名和密码
                gameState.username = getCookie('username');
                gameState.password = getCookie('password');

                if (!gameState.username || !gameState.password) {
                    console.warn('Cookie中未找到用户名或密码，请先登录。');
                    alert('请先登录或注册账号以保存游戏进度！');
                    // 这里可以重定向到登录页面，或者显示登录/注册的模态框
                    // 为了不中断当前流程，暂时不进行重定向，但实际应用中应该处理
                    return; // 不加载数据，使用默认初始状态
                }
                
                // 检查登录状态并获取用户数据
                const response = await fetch(`${API_BASE}/acc_check_password`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: gameState.username,
                        password: gameState.password
                    })
                });
                const data = await response.json();
                
                if (data.success && data.user_data) {
                    const userData = data.user_data;
                    
                    // 恢复玩家位置
                    if (userData.meta_xy) {
                        try {
                            const coords = JSON.parse(userData.meta_xy);
                            gameState.playerX = coords[0] || 0;
                            gameState.playerY = coords[1] || 0;
                            console.log('恢复玩家位置:', gameState.playerX, gameState.playerY);
                        } catch (e) {
                            console.warn('解析玩家位置失败:', e);
                            gameState.playerX = 0;
                            gameState.playerY = 0;
                        }
                    }
                    
                    // 恢复游戏状态
                    gameState.keys = parseInt(userData.meta_key_number) || 0;
                    gameState.powerDevices = parseInt(userData.meta_power_number) || 0;
                    gameState.hasCard = userData.meta_card === true || userData.meta_card === 'true';
                    
                    // 恢复已解锁的格子
                    if (userData.meta_progress) {
                        const progressStr = userData.meta_progress;
                        // 解析格式如 "[0,0][1,1][2,2]" 的字符串
                        const matches = progressStr.match(/\[(\d+),(\d+)\]/g);
                        if (matches) {
                            gameState.unlockedCells.clear();
                            gameState.unlockedCells.add('0,0'); // 确保起点总是解锁的
                            matches.forEach(match => {
                                const coords = match.match(/\[(\d+),(\d+)\]/);
                                if (coords) {
                                    gameState.unlockedCells.add(`${coords[1]},${coords[2]}`);
                                }
                            });
                        }
                    }
                    
                    // 恢复已解决的陷阱和线索
                    if (userData.meta_solved_traps) {
                        try {
                            const solvedTraps = JSON.parse(userData.meta_solved_traps);
                            gameState.solvedTraps = new Set(solvedTraps);
                            
                            // 根据已解决的陷阱恢复线索
                            gameState.clues = [];
                            if (gameState.solvedTraps.has('A1')) {
                                gameState.clues.push(allClues[0], allClues[1]);
                            }
                            if (gameState.solvedTraps.has('B2')) {
                                gameState.clues.push(allClues[2], allClues[3]);
                            }
                            if (gameState.solvedTraps.has('C3')) {
                                gameState.clues.push(allClues[4], allClues[5]);
                            }
                            
                            console.log('已恢复线索:', gameState.clues);
                            console.log('已解决的陷阱:', [...gameState.solvedTraps]);
                        } catch (e) {
                            console.warn('解析已解决陷阱失败:', e);
                        }
                    }
                    
                    // 恢复已激活的电力装置状态
                    if (userData.meta_activated_power_devices) {
                        try {
                            const activatedDevices = JSON.parse(userData.meta_activated_power_devices);
                            gameState.activatedPowerDevices = new Set(activatedDevices);
                            console.log('已恢复激活的电力装置:', [...gameState.activatedPowerDevices]);
                        } catch (e) {
                            console.warn('解析已激活电力装置失败:', e);
                        }
                    }
                    
                    // 恢复4x4谜题状态
                    gameState.puzzle4x4Solved = userData.meta_4x4_solved === true || userData.meta_4x4_solved === 'true';
                    
                    console.log('用户数据加载完成:', gameState);
                } else {
                    console.warn('无法获取用户数据或密码错误/账号不存在:', data.message);
                    alert('登录失败：' + data.message + '。请检查您的账号和密码。');
                    // 这里可以重定向到登录页面，或者显示登录/注册的模态框
                    return; // 不加载数据，使用默认初始状态
                }
            } catch (error) {
                console.error('加载用户数据失败:', error);
                alert('网络错误或API服务不可用，无法加载用户数据。');
                return; // 不加载数据，使用默认初始状态
            }
        }

        // 检查进度
        async function checkProgress() {
            try {
                const response = await fetch(`${API_BASE}/acc_check_password`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: gameState.username,
                        password: gameState.password
                    })
                });
                const data = await response.json();
                
                if (data.success && data.user_data) {
                    const progress = parseInt(data.user_data.progress);
                    
                    if (progress === 9) {
                        // 检查meta时间来决定结局
                        const metaStatus = await getMetaStatus();
                        if (metaStatus.remainingSeconds > 0) {
                            window.location.href = 'ne.html'; // 好结局
                        } else {
                            window.location.href = 'be.html'; // 坏结局
                        }
                        return false;
                    } else if (progress !== 8) {
                        console.warn('进度检查：当前进度为', progress, '，但继续测试');
                        // 在测试模式下继续
                    }
                }
                return true;
            } catch (error) {
                console.error('检查进度失败:', error);
                // 在测试模式下继续
                return true;
            }
        }

        // 获取Cookie
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return '';
        }

        // 初始化迷宫
        function initMaze() {
            const mazeGrid = document.getElementById('mazeGrid');
            mazeGrid.innerHTML = '';
            
            // 从上到下渲染 (y=5到y=0)
            for (let y = 5; y >= 0; y--) {
                for (let x = 0; x < 16; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'maze-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    const cellType = mazeMap[y][x];
                    const isVisible = isCellVisible(x, y);
                    const isUnlocked = gameState.unlockedCells.has(`${x},${y}`);
                    
                    // 设置格子样式和内容
                    setCellAppearance(cell, cellType, x, y, isVisible, isUnlocked);
                    
                    // 添加点击事件
                    if (isVisible && cellType !== 'wall') {
                        cell.addEventListener('click', () => moveToCell(x, y));
                    }
                    
                    mazeGrid.appendChild(cell);
                }
            }
        }

        // 判断格子是否可见
        function isCellVisible(x, y) {
            // 玩家当前位置
            if (x === gameState.playerX && y === gameState.playerY) return true;
            
            // 已解锁的格子
            if (gameState.unlockedCells.has(`${x},${y}`)) return true;
            
            // 玩家周围的格子 (上下左右)
            const dx = Math.abs(x - gameState.playerX);
            const dy = Math.abs(y - gameState.playerY);
            if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) return true;
            
            // 墙壁总是可见
            if (mazeMap[y][x] === 'wall') return true;
            
            return false;
        }

        // 设置格子外观
        function setCellAppearance(cell, cellType, x, y, isVisible, isUnlocked) {
            if (!isVisible) {
                cell.className += ' cell-hidden';
                cell.textContent = '?';
                return;
            }
            
            // 玩家位置
            if (x === gameState.playerX && y === gameState.playerY) {
                cell.className += ' cell-player';
                cell.textContent = '玩家';
                return;
            }
            
            // 根据格子类型设置样式
            switch (cellType) {
                case 'wall':
                    cell.className += ' cell-wall';
                    cell.textContent = '墙';
                    break;
                case 'empty':
                    cell.className += ' cell-empty';
                    cell.textContent = isUnlocked ? '✓' : '空';
                    break;
                case 'start':
                    cell.className += ' cell-start';
                    cell.textContent = '起点';
                    break;
                case 'key':
                    cell.className += ' cell-key';
                    cell.textContent = isUnlocked ? '✓' : '钥匙';
                    break;
                case 'door':
                    cell.className += ' cell-door';
                    cell.textContent = isUnlocked ? '✓' : '门';
                    break;
                case 'trap':
                    cell.className += ' cell-trap';
                    cell.textContent = isUnlocked ? '✓' : '陷阱';
                    break;
                case 'power':
                    cell.className += ' cell-power';
                    cell.textContent = isUnlocked ? '✓' : '电力';
                    break;
                case 'card':
                    cell.className += ' cell-card';
                    cell.textContent = isUnlocked ? '✓' : '卡片';
                    break;
                case 'elevator':
                    cell.className += ' cell-elevator';
                    cell.textContent = '电梯';
                    break;
            }
        }

        // 移动到指定格子
        async function moveToCell(x, y) {
            // 检查是否可以移动到该格子
            if (!canMoveTo(x, y)) {
                return;
            }
            
            const cellType = mazeMap[y][x];
            const cellKey = `${x},${y}`;
            
            // 处理不同类型的格子
            switch (cellType) {
                case 'empty':
                    if (!gameState.unlockedCells.has(cellKey)) {
                        await handleEmptyCell(x, y);
                    } else {
                        movePlayer(x, y);
                    }
                    break;
                    
                case 'door':
                    if (!gameState.unlockedCells.has(cellKey)) {
                        await handleDoorCell(x, y);
                    } else {
                        movePlayer(x, y);
                    }
                    break;
                    
                case 'key':
                    if (!gameState.unlockedCells.has(cellKey)) {
                        await handleKeyCell(x, y);
                    } else {
                        movePlayer(x, y);
                    }
                    break;
                    
                case 'trap':
                    if (!gameState.unlockedCells.has(cellKey)) {
                        await handleTrapCell(x, y);
                    } else {
                        movePlayer(x, y);
                    }
                    break;
                    
                case 'power':
                    if (!gameState.unlockedCells.has(cellKey)) {
                        await handlePowerCell(x, y);
                    } else {
                        movePlayer(x, y);
                    }
                    break;
                    
                case 'card':
                    if (!gameState.unlockedCells.has(cellKey)) {
                        await handleCardCell(x, y);
                    } else {
                        movePlayer(x, y);
                    }
                    break;
                    
                case 'elevator':
                    await handleElevatorCell(x, y);
                    break;
                    
                default:
                    movePlayer(x, y);
                    break;
            }
        }

        // 检查是否可以移动到指定位置
        function canMoveTo(x, y) {
            // 检查边界
            if (x < 0 || x >= 16 || y < 0 || y >= 6) return false;
            
            // 检查是否是墙
            if (mazeMap[y][x] === 'wall') return false;
            
            // 检查是否相邻
            const dx = Math.abs(x - gameState.playerX);
            const dy = Math.abs(y - gameState.playerY);
            if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) return true; // 允许上下左右移动
            
            return false; // 不相邻则不能移动
        }

        // 移动玩家
        async function movePlayer(x, y) {
            const oldX = gameState.playerX;
            const oldY = gameState.playerY;
            
            gameState.playerX = x;
            gameState.playerY = y;
            
            console.log(`玩家移动: [${oldX},${oldY}] -> [${x},${y}]`);
            
            // 实时保存玩家位置到后端
            try {
                await updatePlayerPosition(x, y);
                console.log('玩家位置已保存到后端');
            } catch (error) {
                console.error('保存玩家位置失败:', error);
            }
            
            // 每移动一步扣除meta时间
            try {
                await diminishMetaTime();
            } catch (error) {
                console.error('扣除时间失败:', error);
            }
            
            // 优化渲染：只更新必要的格子而不是重新渲染整个迷宫
            updateMazeDisplay(oldX, oldY, x, y);
            updateDisplay();
        }

        // 优化的迷宫显示更新函数
        function updateMazeDisplay(oldX, oldY, newX, newY) {
            // 更新旧位置的格子
            const oldCell = document.querySelector(`[data-x="${oldX}"][data-y="${oldY}"]`);
            if (oldCell) {
                const cellType = mazeMap[oldY][oldX];
                const isVisible = isCellVisible(oldX, oldY);
                const isUnlocked = gameState.unlockedCells.has(`${oldX},${oldY}`);
                setCellAppearance(oldCell, cellType, oldX, oldY, isVisible, isUnlocked);
            }
            
            // 更新新位置的格子
            const newCell = document.querySelector(`[data-x="${newX}"][data-y="${newY}"]`);
            if (newCell) {
                const cellType = mazeMap[newY][newX];
                const isVisible = isCellVisible(newX, newY);
                const isUnlocked = gameState.unlockedCells.has(`${newX},${newY}`);
                setCellAppearance(newCell, cellType, newX, newY, isVisible, isUnlocked);
            }
            
            // 更新周围格子的可见性
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const x = newX + dx;
                    const y = newY + dy;
                    if (x >= 0 && x < 16 && y >= 0 && y < 6) {
                        const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                        if (cell) {
                            const cellType = mazeMap[y][x];
                            const isVisible = isCellVisible(x, y);
                            const isUnlocked = gameState.unlockedCells.has(`${x},${y}`);
                            setCellAppearance(cell, cellType, x, y, isVisible, isUnlocked);
                        }
                    }
                }
            }
        }

        // 处理空格子
        async function handleEmptyCell(x, y) {
            // 检查冷却状态
            const cooldownStatus = await checkSimpleCooldown();
            if (cooldownStatus.cooldownRemaining > 0) {
                showCooldownNotice('simple', cooldownStatus.cooldownRemaining);
                return;
            }
            
            // 获取随机谜题
            const puzzle = await getRandomPuzzle();
            if (puzzle && puzzle.success) { // 确保谜题获取成功
                showPuzzleModal(puzzle.puzzle, x, y); // 传递谜题对象和目标坐标
            } else {
                console.error('获取随机谜题失败或无可用谜题:', puzzle);
                alert('无法获取谜题，请稍后再试。');
            }
        }

        // 处理门格子
        async function handleDoorCell(x, y) {
            if (gameState.keys > 0) {
                // 消耗钥匙
                gameState.keys--;
                await updateUserData('meta_key_number', gameState.keys.toString());
                
                // 解锁格子
                await unlockCell(x, y);
                movePlayer(x, y);
            } else {
                alert('需要钥匙才能通过这扇门！');
            }
        }

        // 处理钥匙格子
        async function handleKeyCell(x, y) {
            // 获得钥匙
            gameState.keys++;
            await updateUserData('meta_key_number', gameState.keys.toString());
            
            // 解锁格子并扣除时间
            await unlockCell(x, y);
            await diminishMetaTime(); // 解锁格子额外扣除时间
            
            movePlayer(x, y);
        }

        // 处理陷阱格子（守门员）
        async function handleTrapCell(x, y) {
            // 确定陷阱ID
            let trapId;
            if (x === 2 && y === 5) trapId = 'A1';
            else if (x === 13 && y === 4) trapId = 'B2';
            else if (x === 15 && y === 1) trapId = 'C3';
            
            if (trapId) {
                // 检查是否已经解决过这个陷阱
                if (gameState.solvedTraps.has(trapId)) {
                    // 已解决，直接移动
                    movePlayer(x, y);
                    return;
                }
                
                // 检查冷却状态
                const cooldownStatus = await checkGoalkeeperCooldown();
                if (cooldownStatus.cooldownRemaining > 0) {
                    alert(`守门员谜题处于冷却中，请等待 ${cooldownStatus.cooldownRemaining} 秒后重试。`);
                    return;
                }
                
                // 跳转到对应的守门员谜题页面
                window.location.href = `${trapId}.html`;
            }
        }

        // 处理电力装置格子
        async function handlePowerCell(x, y) {
            const powerDeviceKey = `${x},${y}`;
            
            // 检查是否已经激活过这个电力装置
            if (gameState.activatedPowerDevices.has(powerDeviceKey)) {
                // 已激活，直接移动
                movePlayer(x, y);
                return;
            }
            
            // 检查对应的陷阱是否已解锁
            let requiredTrap;
            if (x === 1 && y === 5) requiredTrap = '2,5'; // A1陷阱
            else if (x === 14 && y === 5) requiredTrap = '13,4'; // B2陷阱
            else if (x === 15 && y === 0) requiredTrap = '15,1'; // C3陷阱
            
            if (requiredTrap && gameState.unlockedCells.has(requiredTrap)) {
                // 激活电力装置
                gameState.powerDevices++;
                gameState.activatedPowerDevices.add(powerDeviceKey);
                
                // 保存状态到后端
                await updateUserData('meta_power_number', gameState.powerDevices.toString());
                await updateUserData('meta_activated_power_devices', JSON.stringify([...gameState.activatedPowerDevices]));
                
                // 显示线索
                showPowerDeviceClues(x, y);
                
                // 解锁格子并扣除时间
                await unlockCell(x, y);
                await diminishMetaTime(); // 解锁格子额外扣除时间
                
                movePlayer(x, y);
                
                console.log(`电力装置 [${x},${y}] 已激活，当前激活数量: ${gameState.powerDevices}`);
            } else {
                alert('需要先解决对应的守门员谜题才能激活电力装置！');
            }
        }

        // 处理门禁卡格子
        async function handleCardCell(x, y) {
            // 获得门禁卡
            gameState.hasCard = true;
            await updateUserData('meta_card', 'true');
            
            // 解锁格子并扣除时间
            await unlockCell(x, y);
            await diminishMetaTime(); // 解锁格子额外扣除时间
            
            movePlayer(x, y);
        }

        // 处理电梯格子
        async function handleElevatorCell(x, y) {
            movePlayer(x, y);
            show4x4Modal();
        }

        // 解锁格子
        async function unlockCell(x, y) {
            const cellKey = `${x},${y}`;
            gameState.unlockedCells.add(cellKey);
            
            // 更新后端进度
            try {
                await addMetaProgress(x, y);
                console.log(`格子 [${x},${y}] 已解锁并保存到后端`);
            } catch (error) {
                console.error('保存格子解锁状态失败:', error);
            }
            
            // 只更新这个格子的显示，而不是重新渲染整个迷宫
            const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                const cellType = mazeMap[y][x];
                const isVisible = isCellVisible(x, y);
                setCellAppearance(cell, cellType, x, y, isVisible, true);
            }
        }

        // 显示小谜题模态框
        function showPuzzleModal(puzzleData, targetX, targetY) {
            document.getElementById('puzzleQuestion').textContent = puzzleData.puzzle;
            document.getElementById('puzzleAnswer').value = '';
            document.getElementById('puzzleModal').style.display = 'block';
            
            // 存储目标位置和正确答案
            window.currentPuzzleTarget = { x: targetX, y: targetY, answer: puzzleData.key };
        }

        // 关闭小谜题模态框
        function closePuzzleModal() {
            document.getElementById('puzzleModal').style.display = 'none';
            window.currentPuzzleTarget = null;
        }

        // 跳过小谜题
        async function skipPuzzle() {
            const target = window.currentPuzzleTarget;
            if (!target) return;
            
            // 确认跳过
            if (!confirm('跳过谜题将扣除额外时间，确定要跳过吗？')) {
                return;
            }
            
            // 关闭模态框
            closePuzzleModal();
            
            // 扣除额外时间（跳过的惩罚）
            await diminishMetaTime();
            await diminishMetaTime(); // 额外扣除一次
            
            // 不解锁格子，直接返回
            alert('已跳过谜题，扣除了额外时间。您可以稍后再来挑战。');
        }

        // 提交小谜题答案
        async function submitPuzzleAnswer() {
            const answer = document.getElementById('puzzleAnswer').value.trim();
            const target = window.currentPuzzleTarget;
            
            if (!target) return;
            
            if (answer === target.answer) {
                // 答案正确
                closePuzzleModal();
                
                // 解锁格子并扣除时间
                await unlockCell(target.x, target.y);
                await diminishMetaTime(); // 解锁格子额外扣除时间
                
                // 自动移动到该格子
                movePlayer(target.x, target.y);
            } else {
                // 答案错误，触发冷却
                await startSimpleCooldown();
                const cooldownStatus = await checkSimpleCooldown();
                showCooldownNotice('simple', cooldownStatus.cooldownRemaining);
            }
        }

        // 显示守门员谜题模态框
        function showGoalkeeperModal(trapId, targetX, targetY) {
            document.getElementById('goalkeeperTitle').textContent = `守门员谜题 - ${trapId}`;
            document.getElementById('goalkeeperAnswer').value = '';
            document.getElementById('goalkeeperModal').style.display = 'block';
            
            // 存储目标位置和陷阱ID
            window.currentGoalkeeperTarget = { x: targetX, y: targetY, trapId: trapId };
        }

        // 关闭守门员谜题模态框
        function closeGoalkeeperModal() {
            document.getElementById('goalkeeperModal').style.display = 'none';
            window.currentGoalkeeperTarget = null;
        }

        // 提交守门员答案
        async function submitGoalkeeperAnswer() {
            const answer = document.getElementById('goalkeeperAnswer').value.trim();
            const target = window.currentGoalkeeperTarget;
            
            if (!target) return;
            
            try {
                const response = await fetch(`${API_BASE}/check_goalkeeper_key`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: gameState.username,
                        id: target.trapId,
                        key: answer
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // 守门员谜题解决成功
                    closeGoalkeeperModal();
                    
                    // 添加对应的线索
                    addCluesForTrap(target.trapId);
                    
                    // 解锁格子并移动玩家
                    await unlockCell(target.x, target.y);
                    movePlayer(target.x, target.y);
                } else {
                    // 答案错误，显示冷却
                    const cooldownStatus = await checkGoalkeeperCooldown();
                    showGoalkeeperCooldownNotice(cooldownStatus.cooldownRemaining);
                }
            } catch (error) {
                console.error('提交守门员答案失败:', error);
            }
        }

        // 显示守门员冷却提示
        function showGoalkeeperCooldownNotice(seconds) {
            const notice = document.getElementById('goalkeeperCooldown');
            const timeSpan = document.getElementById('goalkeeperCooldownTime');
            timeSpan.textContent = seconds;
            notice.style.display = 'block';
            
            // 倒计时
            const countdown = setInterval(() => {
                seconds--;
                timeSpan.textContent = seconds;
                if (seconds <= 0) {
                    clearInterval(countdown);
                    notice.style.display = 'none';
                }
            }, 1000);
        }

        // 显示4x4谜题模态框
        function show4x4Modal() {
            // 显示所有已获得的线索
            const allObtainedClues = gameState.clues;
            if (allObtainedClues.length > 0) {
                const cluesHtml = allObtainedClues.map(clue => `<div class="clue-item">${clue}</div>`).join('');
                document.getElementById('puzzle4x4Content').innerHTML = `
                    <p>请根据所有线索填入正确的数字排列：</p>
                    <div style="margin: 15px 0;">
                        <h4>已获得的线索：</h4>
                        ${cluesHtml}
                    </div>
                    <p style="color: #ffff00; margin: 10px 0;">格式：每行输入4个数字，用空格分隔</p>
                    
                    <div class="puzzle-4x4-grid">
                        <input type="text" class="puzzle-4x4-input" id="row1" placeholder="1 2 3 4">
                        <input type="text" class="puzzle-4x4-input" id="row2" placeholder="4 3 2 1">
                        <input type="text" class="puzzle-4x4-input" id="row3" placeholder="2 5 1 4">
                        <input type="text" class="puzzle-4x4-input" id="row4" placeholder="1 2 3 4">
                    </div>
                    
                    <div id="puzzle4x4Cooldown" class="cooldown-notice" style="display: none;">
                        <p>答案错误！请等待 <span id="puzzle4x4CooldownTime">0</span> 秒后重试</p>
                    </div>
                    
                    <button class="btn" onclick="submit4x4Answer()">提交答案</button>
                    <button class="btn escape-btn" onclick="attemptEscape()" id="escapeBtn">逃生</button>
                `;
            } else {
                document.getElementById('puzzle4x4Content').innerHTML = `
                    <p>请根据线索填入正确的数字排列：</p>
                    <div style="margin: 15px 0; color: #ff6666;">
                        <h4>提示：</h4>
                        <p>您还没有获得任何线索！请先解决守门员谜题来获取线索。</p>
                    </div>
                    <p style="color: #ffff00; margin: 10px 0;">格式：每行输入4个数字，用空格分隔</p>
                    
                    <div class="puzzle-4x4-grid">
                        <input type="text" class="puzzle-4x4-input" id="row1" placeholder="1 2 3 4">
                        <input type="text" class="puzzle-4x4-input" id="row2" placeholder="4 3 2 1">
                        <input type="text" class="puzzle-4x4-input" id="row3" placeholder="2 5 1 4">
                        <input type="text" class="puzzle-4x4-input" id="row4" placeholder="1 2 3 4">
                    </div>
                    
                    <div id="puzzle4x4Cooldown" class="cooldown-notice" style="display: none;">
                        <p>答案错误！请等待 <span id="puzzle4x4CooldownTime">0</span> 秒后重试</p>
                    </div>
                    
                    <button class="btn" onclick="submit4x4Answer()">提交答案</button>
                    <button class="btn escape-btn" onclick="attemptEscape()" id="escapeBtn">逃生</button>
                `;
            }
            
            document.getElementById('puzzle4x4Modal').style.display = 'block';
        }

        // 关闭4x4模态框
        function close4x4Modal() {
            document.getElementById('puzzle4x4Modal').style.display = 'none';
        }

        // 提交4x4答案
        async function submit4x4Answer() {
            // 检查冷却状态
            const cooldownStatus = await check4x4Cooldown();
            if (cooldownStatus.cooldownRemaining > 0) {
                show4x4CooldownNotice(cooldownStatus.cooldownRemaining);
                return;
            }
            
            const row1 = document.getElementById('row1').value.trim();
            const row2 = document.getElementById('row2').value.trim();
            const row3 = document.getElementById('row3').value.trim();
            const row4 = document.getElementById('row4').value.trim();
            
            const keys = [row1, row2, row3, row4];
            
            try {
                const response = await fetch(`${API_BASE}/check_4x4_key`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: gameState.username,
                        keys: keys
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // 4x4谜题解决
                    gameState.puzzle4x4Solved = true;
                    await updateUserData('meta_4x4_solved', 'true');
                    alert('4x4谜题解决成功！现在可以尝试逃生了。');
                    updateDisplay();
                } else {
                    // 答案错误，显示冷却
                    const cooldownStatus = await check4x4Cooldown();
                    show4x4CooldownNotice(cooldownStatus.cooldownRemaining);
                }
            } catch (error) {
                console.error('提交4x4答案失败:', error);
            }
        }

        // 尝试逃生
        async function attemptEscape() {
            // 检查条件2: 三个电力装置都解锁
            if (gameState.powerDevices < 3) {
                alert('逃生失败：还有电力装置未激活！');
                return;
            }
            
            // 检查条件3: 持有门禁卡
            if (!gameState.hasCard) {
                alert('逃生失败：需要门禁卡！');
                return;
            }
            
            // 检查条件4: 4x4谜题已解决
            if (!gameState.puzzle4x4Solved) {
                alert('逃生失败：需要先解决4x4谜题！');
                return;
            }
            
            // 检查条件1: 时间是否还有剩余
            const metaStatus = await getMetaStatus();
            
            // 设置进度为9
            await updateUserData('progress', '9');
            
            if (metaStatus.remainingSeconds > 0) {
                // 好结局
                window.location.href = 'ne.html';
            } else {
                // 坏结局
                window.location.href = 'be.html';
            }
        }

        // 添加陷阱对应的线索
        function addCluesForTrap(trapId) {
            let newClues = [];
            if (trapId === 'A1') {
                newClues = [allClues[0], allClues[1]]; // 前两条线索
            } else if (trapId === 'B2') {
                newClues = [allClues[2], allClues[3]]; // 第3-4条线索
            } else if (trapId === 'C3') {
                newClues = [allClues[4], allClues[5]]; // 第5-6条线索
            }
            
            // 避免重复添加线索
            newClues.forEach(clue => {
                if (!gameState.clues.includes(clue)) {
                    gameState.clues.push(clue);
                }
            });
            
            gameState.solvedTraps.add(trapId);
            
            console.log(`陷阱 ${trapId} 已解决，添加线索:`, newClues);
            console.log('当前所有线索:', gameState.clues);
            
            // 保存已解决的陷阱到后端
            updateUserData('meta_solved_traps', JSON.stringify([...gameState.solvedTraps]));
            
            // 立即更新显示
            updateDisplay();
            
            // 再次确保显示更新
            setTimeout(() => {
                updateDisplay();
                console.log('延迟更新线索显示完成');
            }, 100);
        }

        // 显示电力装置线索
        function showPowerDeviceClues(x, y) {
            let clues = [];
            let trapId = '';
            
            if (x === 1 && y === 5) {
                clues = [allClues[0], allClues[1]];
                trapId = 'A1';
            } else if (x === 14 && y === 5) {
                clues = [allClues[2], allClues[3]];
                trapId = 'B2';
            } else if (x === 15 && y === 0) {
                clues = [allClues[4], allClues[5]];
                trapId = 'C3';
            }
            
            // 检查对应的陷阱是否已解决
            if (gameState.solvedTraps.has(trapId)) {
                // 陷阱已解决，显示线索
                if (clues.length > 0) {
                    // 避免重复添加线索
                    clues.forEach(clue => {
                        if (!gameState.clues.includes(clue)) {
                            gameState.clues.push(clue);
                        }
                    });
                    
                    alert(`电力装置激活！获得线索：\n${clues.join('\n')}`);
                    
                    // 立即更新显示
                    updateDisplay();
                    
                    console.log(`电力装置 [${x},${y}] 激活，添加线索:`, clues);
                    console.log('当前所有线索:', gameState.clues);
                }
            } else {
                alert('电力装置激活成功，但需要先解决对应的守门员谜题才能获得线索！');
            }
        }

        // 显示冷却提示
        function showCooldownNotice(type, seconds) {
            if (type === 'simple') {
                const notice = document.getElementById('cooldownNotice');
                const timeSpan = document.getElementById('cooldownTime');
                timeSpan.textContent = seconds;
                notice.style.display = 'block';
                
                // 倒计时
                const countdown = setInterval(() => {
                    seconds--;
                    timeSpan.textContent = seconds;
                    if (seconds <= 0) {
                        clearInterval(countdown);
                        notice.style.display = 'none';
                    }
                }, 1000);
            } else if (type === 'goalkeeper') {
                alert(`守门员谜题处于冷却中，请等待 ${seconds} 秒后重试。`);
            }
        }

        // 显示4x4冷却提示
        function show4x4CooldownNotice(seconds) {
            const notice = document.getElementById('puzzle4x4Cooldown');
            const timeSpan = document.getElementById('puzzle4x4CooldownTime');
            timeSpan.textContent = seconds;
            notice.style.display = 'block';
            
            // 倒计时
            const countdown = setInterval(() => {
                seconds--;
                timeSpan.textContent = seconds;
                if (seconds <= 0) {
                    clearInterval(countdown);
                    notice.style.display = 'none';
                }
            }, 1000);
        }

        // 更新显示
        function updateDisplay() {
            // 更新状态信息
            document.getElementById('playerPosition').textContent = `[${gameState.playerX},${gameState.playerY}]`;
            document.getElementById('keyCount').textContent = gameState.keys;
            document.getElementById('powerCount').textContent = `${gameState.powerDevices}/3`;
            document.getElementById('cardStatus').textContent = gameState.hasCard ? '已获得' : '未获得';
            
            // 更新线索
            const cluesList = document.getElementById('cluesList');
            console.log('updateDisplay被调用，当前线索数量:', gameState.clues.length);
            console.log('当前线索内容:', gameState.clues);
            
            if (gameState.clues && gameState.clues.length > 0) {
                const cluesHtml = gameState.clues.map(clue => 
                    `<div class="clue-item">${clue}</div>`
                ).join('');
                cluesList.innerHTML = cluesHtml;
                console.log('线索HTML已设置:', cluesHtml);
            } else {
                cluesList.innerHTML = '<div style="color: #666; font-style: italic;">暂无线索</div>';
                console.log('设置为暂无线索');
            }
        }

        // 开始时间监控
        function startTimeMonitoring() {
            setInterval(async () => {
                const metaStatus = await getMetaStatus();
                updateTimeDisplay(metaStatus.remainingSeconds);
            }, 1000);
        }

        // 更新时间显示
        function updateTimeDisplay(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            const timeStr = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            
            document.getElementById('timeText').textContent = `剩余时间: ${timeStr}`;
            document.getElementById('timeRemaining').textContent = timeStr;
            
            // 更新血条
            const maxTime = 1800; // 假设最大时间为30分钟
            const percentage = Math.max(0, (seconds / maxTime) * 100);
            document.getElementById('timeBarFill').style.width = `${percentage}%`;
        }

        // API调用函数
        async function getRandomPuzzle() {
            try {
                const response = await fetch(`${API_BASE}/random`);
                const data = await response.json();
                return data; // 返回整个数据对象，包含success和puzzle字段
            } catch (error) {
                console.error('获取随机谜题失败:', error);
                return { success: false, puzzle: null };
            }
        }

        async function checkSimpleCooldown() {
            try {
                const response = await fetch(`${API_BASE}/simple_cooldown_status`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username: gameState.username })
                });
                return await response.json();
            } catch (error) {
                console.error('检查简单冷却失败:', error);
                return { cooldownRemaining: 0 };
            }
        }

        async function startSimpleCooldown() {
            try {
                await fetch(`${API_BASE}/start_simple_cooldown`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username: gameState.username })
                });
            } catch (error) {
                console.error('开始简单冷却失败:', error);
            }
        }

        async function checkGoalkeeperCooldown() {
            try {
                const response = await fetch(`${API_BASE}/goalkeeper_cooldown_status`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username: gameState.username })
                });
                return await response.json();
            } catch (error) {
                console.error('检查守门员冷却失败:', error);
                return { cooldownRemaining: 0 };
            }
        }

        async function startGoalkeeperCooldown() {
            try {
                await fetch(`${API_BASE}/start_goalkeeper_cooldown`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username: gameState.username })
                });
            } catch (error) {
                console.error('开始守门员冷却失败:', error);
            }
        }

        async function check4x4Cooldown() {
            try {
                const response = await fetch(`${API_BASE}/4x4_cooldown_status`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username: gameState.username })
                });
                return await response.json();
            } catch (error) {
                console.error('检查4x4冷却失败:', error);
                return { cooldownRemaining: 0 };
            }
        }

        async function updateUserData(option, value) {
            try {
                const response = await fetch(`${API_BASE}/set_user_data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: gameState.username,
                        option: option,
                        value: value
                    })
                });
                const data = await response.json();
                if (data.success) {
                    console.log(`用户数据已更新: ${option} = ${value}`);
                } else {
                    console.error('更新用户数据失败:', data.message);
                }
            } catch (error) {
                console.error('更新用户数据失败:', error);
            }
        }

        async function updatePlayerPosition(x, y) {
            try {
                const response = await fetch(`${API_BASE}/change_meta_xy`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: gameState.username,
                        new_xy: `[${x},${y}]`
                    })
                });
                const data = await response.json();
                if (data.success) {
                    console.log(`玩家位置已更新: [${x},${y}]`);
                } else {
                    console.error('更新玩家位置失败:', data.message);
                }
            } catch (error) {
                console.error('更新玩家位置失败:', error);
            }
        }

        async function addMetaProgress(x, y) {
            try {
                const response = await fetch(`${API_BASE}/add_meta`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        username: gameState.username,
                        progress: `[${x},${y}]`
                    })
                });
                const data = await response.json();
                if (data.success) {
                    console.log(`Meta进度已添加: [${x},${y}]`);
                } else {
                    console.error('添加Meta进度失败:', data.message);
                }
            } catch (error) {
                console.error('添加Meta进度失败:', error);
            }
        }

        async function diminishMetaTime() {
            try {
                const response = await fetch(`${API_BASE}/diminish_meta_time`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                const data = await response.json();
                if (data.success) {
                    console.log('Meta时间已扣除');
                } else {
                    console.error('扣除Meta时间失败:', data.message);
                }
            } catch (error) {
                console.error('减少Meta时间失败:', error);
            }
        }

        async function getMetaStatus() {
            try {
                const response = await fetch(`${API_BASE}/meta-status`);
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('获取Meta状态失败:', error);
                return { remainingSeconds: 0 };
            }
        }

        // 处理从守门员页面返回的情况
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'trapSolved') {
                const trapId = event.data.trapId;
                addCluesForTrap(trapId);
                
                // 解锁对应的陷阱格子
                let trapX, trapY;
                if (trapId === 'A1') { trapX = 2; trapY = 5; }
                else if (trapId === 'B2') { trapX = 13; trapY = 4; }
                else if (trapId === 'C3') { trapX = 15; trapY = 1; }
                
                if (trapX !== undefined && trapY !== undefined) {
                    unlockCell(trapX, trapY);
                    movePlayer(trapX, trapY);
                }
            }
        });

        // 页面加载完成后初始化游戏
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>


